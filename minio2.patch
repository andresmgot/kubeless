diff --git a/cmd/kubeless/function.go b/cmd/kubeless/function.go
index e698ca0c..605e7e68 100644
--- a/cmd/kubeless/function.go
+++ b/cmd/kubeless/function.go
@@ -22,6 +22,7 @@ import (
 	"encoding/hex"
 	"errors"
 	"fmt"
+	"github.com/Sirupsen/logrus"
 	"io"
 	"io/ioutil"
 	"net/http"
@@ -29,6 +30,7 @@ import (
 	"path"
 	"strings"
 
+	"github.com/kubeless/kubeless/pkg/minio"
 	"github.com/kubeless/kubeless/pkg/spec"
 	"github.com/spf13/cobra"
 	"k8s.io/apimachinery/pkg/api/resource"
@@ -117,6 +119,23 @@ func getFileSha256(file string) (string, error) {
 	return checksum, err
 }
 
+func isMinioAvailable(cli kubernetes.Interface) bool {
+	_, err := cli.Core().Services("kubeless").Get("minio", metav1.GetOptions{})
+	if err != nil {
+		return false
+	}
+	minioPods, err := cli.Core().Pods("kubeless").List(metav1.ListOptions{
+		LabelSelector: "kubeless=minio",
+	})
+	for i := range minioPods.Items {
+		if minioPods.Items[i].Status.Phase != "Running" {
+			logrus.Warn("Found unhealthy Minio pod, disabling upload")
+			return false
+		}
+	}
+	return true
+}
+
 func uploadFunction(file string, cli kubernetes.Interface) (string, string, string, error) {
 	var function, contentType, checksum string
 	stats, err := os.Stat(file)
@@ -127,31 +146,49 @@ func uploadFunction(file string, cli kubernetes.Interface) (string, string, stri
 		err = errors.New("The maximum size of a function is 50MB")
 		return "", "", "", err
 	}
-	// If an object storage service is not available check
-	// that the file is not over 1MB to store it as a Custom Resource
-	if stats.Size() > int64(1*1024*1024) {
-		err = errors.New("Unable to deploy functions over 1MB withouth a storage service")
-		return "", "", "", err
-	}
-	functionBytes, err := ioutil.ReadFile(file)
-	if err != nil {
-		return "", "", "", err
-	}
-	if err != nil {
-		return "", "", "", err
-	}
-	fileType := http.DetectContentType(functionBytes)
-	if strings.Contains(fileType, "text/plain") {
-		function = string(functionBytes[:])
-		contentType = "text"
+
+	if isMinioAvailable(cli) {
+		var rawChecksum string
+		rawChecksum, err := getFileSha256(file)
+		if err != nil {
+			return "", "", "", err
+		}
+		function, err = minio.UploadFunction(file, rawChecksum, cli)
+		if err != nil {
+			return "", "", "", err
+		}
+		checksum = "sha256:" + rawChecksum
+		contentType = "URL"
+		if err != nil {
+			return "", "", "", err
+		}
 	} else {
-		function = base64.StdEncoding.EncodeToString(functionBytes)
-		contentType = "base64"
-	}
-	c, err := getFileSha256(file)
-	checksum = "sha256:" + c
-	if err != nil {
-		return "", "", "", err
+		// If an object storage service is not available check
+		// that the file is not over 1MB to store it as a Custom Resource
+		if stats.Size() > int64(1*1024*1024) {
+			err = errors.New("Unable to deploy functions over 1MB withouth a storage service")
+			return "", "", "", err
+		}
+		functionBytes, err := ioutil.ReadFile(file)
+		if err != nil {
+			return "", "", "", err
+		}
+		if err != nil {
+			return "", "", "", err
+		}
+		fileType := http.DetectContentType(functionBytes)
+		if strings.Contains(fileType, "text/plain") {
+			function = string(functionBytes[:])
+			contentType = "text"
+		} else {
+			function = base64.StdEncoding.EncodeToString(functionBytes)
+			contentType = "base64"
+		}
+		c, err := getFileSha256(file)
+		checksum = "sha256:" + c
+		if err != nil {
+			return "", "", "", err
+		}
 	}
 	return function, contentType, checksum, nil
 }
diff --git a/cmd/kubeless/function_test.go b/cmd/kubeless/function_test.go
index 8b1204be..4763d895 100644
--- a/cmd/kubeless/function_test.go
+++ b/cmd/kubeless/function_test.go
@@ -27,7 +27,10 @@ import (
 	"github.com/kubeless/kubeless/pkg/spec"
 	"k8s.io/apimachinery/pkg/api/resource"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/client-go/kubernetes/fake"
+	batchv1 "k8s.io/client-go/pkg/apis/batch/v1"
+	core "k8s.io/client-go/testing"
 )
 
 func TestParseLabel(t *testing.T) {
@@ -217,4 +220,80 @@ func TestGetFunctionDescription(t *testing.T) {
 		t.Error("Unexpected result")
 	}
 
+	// It should upload the function if Minio is available
+	minioFakeSvc := v1.Service{
+		ObjectMeta: metav1.ObjectMeta{
+			Namespace: "kubeless",
+			Name:      "minio",
+		},
+	}
+	uploadFakeJob := batchv1.Job{
+		ObjectMeta: metav1.ObjectMeta{
+			Namespace: "kubeless",
+			Name:      "upload-file",
+		},
+		Status: batchv1.JobStatus{
+			Succeeded: 1,
+		},
+	}
+	cli := &fake.Clientset{}
+	cli.Fake.AddReactor("get", "services", func(action core.Action) (bool, runtime.Object, error) {
+		return true, &minioFakeSvc, nil
+	})
+	cli.Fake.AddReactor("get", "jobs", func(action core.Action) (bool, runtime.Object, error) {
+		return true, &uploadFakeJob, nil
+	})
+	result4, err := getFunctionDescription("test", "default", "file.handler", file.Name(), "dependencies", "runtime", "", "", "test-image", "128Mi", true, []string{"TEST=1"}, []string{"test=1"}, spec.Function{}, cli)
+	if err != nil {
+		t.Error(err)
+	}
+	expectedFunction = spec.Function{
+		TypeMeta: metav1.TypeMeta{
+			Kind:       "Function",
+			APIVersion: "k8s.io/v1",
+		},
+		Metadata: metav1.ObjectMeta{
+			Name:      "test",
+			Namespace: "default",
+			Labels: map[string]string{
+				"test": "1",
+			},
+		},
+		Spec: spec.FunctionSpec{
+			Handler:     "file.handler",
+			Runtime:     "runtime",
+			Type:        "HTTP",
+			Function:    "http://minio.kubeless:9000/functions/" + path.Base(file.Name()) + ".1958eb96d7d3cadedd0f327f09322eb7db296afb282ed91aa66cb4ab0dcc3c9f",
+			File:        path.Base(file.Name()),
+			ContentType: "URL",
+			Checksum:    "sha256:1958eb96d7d3cadedd0f327f09322eb7db296afb282ed91aa66cb4ab0dcc3c9f",
+			Deps:        "dependencies",
+			Topic:       "",
+			Schedule:    "",
+			Template: v1.PodTemplateSpec{
+				Spec: v1.PodSpec{
+					Containers: []v1.Container{
+						{
+							Env: []v1.EnvVar{{
+								Name:  "TEST",
+								Value: "1",
+							}},
+							Resources: v1.ResourceRequirements{
+								Limits: map[v1.ResourceName]resource.Quantity{
+									v1.ResourceMemory: parsedMem,
+								},
+								Requests: map[v1.ResourceName]resource.Quantity{
+									v1.ResourceMemory: parsedMem,
+								},
+							},
+							Image: "test-image",
+						},
+					},
+				},
+			},
+		},
+	}
+	if !reflect.DeepEqual(expectedFunction, *result4) {
+		t.Error("Unexpected result")
+	}
 }
diff --git a/manifests/minio/minio.yaml b/manifests/minio/minio.yaml
new file mode 100644
index 00000000..b3cfe21f
--- /dev/null
+++ b/manifests/minio/minio.yaml
@@ -0,0 +1,126 @@
+# NOTE:
+# It is necessary to first deploy a secret that minio will use
+# for retrieving the username and password. To generate it
+# execute:
+# $ kubectl create secret generic minio-key --namespace kubeless --from-literal=accesskey=<username> --from-literal=secretkey=<password>
+---
+kind: PersistentVolumeClaim
+apiVersion: v1
+metadata:
+  name: minio
+  namespace: kubeless
+  annotations:
+    volume.alpha.kubernetes.io/storage-class: standard
+spec:
+  storageClassName: standard
+  accessModes:
+    - "ReadWriteOnce"
+  resources:
+    requests:
+      storage: "10Gi"
+---
+kind: Service
+apiVersion: v1
+metadata:
+  name: minio
+  namespace: kubeless
+  labels:
+    kubeless: minio
+spec:
+  selector:
+    kubeless: minio
+  ports:
+    - port: 9000
+      targetPort: 9000
+      protocol: TCP
+---
+apiVersion: extensions/v1beta1
+kind: Deployment
+metadata:
+  name: minio
+  namespace: kubeless
+  labels:
+    kubeless: minio
+spec:
+  selector:
+    matchLabels:
+      kubeless: minio
+  template:
+    metadata:
+      name: minio
+      labels:
+        kubeless: minio
+      annotations:
+        pod.beta.kubernetes.io/init-containers: '[
+          {
+            "name": "init-myservice",
+            "image": "busybox",
+            "command": ["mkdir", "-p", "/export/functions"],
+            "volumeMounts": [{
+              "name": "export",
+              "mountPath": "/export"
+            }]
+          }
+        ]'
+    spec:
+      volumes:
+        - name: export
+          persistentVolumeClaim:
+            claimName: minio
+      containers:
+        - name: minio
+          image: minio/minio:RELEASE.2017-02-16T01-47-30Z
+          imagePullPolicy: Always
+          command: ["minio"]
+          args: ["server", "/export"]
+          volumeMounts:
+            - name: export
+              mountPath: /export
+          ports:
+            - name: service
+              containerPort: 9000
+          env:
+            - name: MINIO_ACCESS_KEY
+              valueFrom:
+                secretKeyRef:
+                  name: minio-key
+                  key: accesskey
+            - name: MINIO_SECRET_KEY
+              valueFrom:
+                secretKeyRef:
+                  name: minio-key
+                  key: secretkey
+          livenessProbe:
+            tcpSocket:
+              port: 9000
+            timeoutSeconds: 1
+          resources:
+            requests:
+              cpu: 250m
+              memory: 256Mi
+---
+apiVersion: batch/v1
+kind: Job
+metadata:
+  name: set-policy
+  namespace: kubeless
+spec:
+  template:
+    metadata:
+      name:  set-policy
+    spec:
+      volumes:
+        - name: keys
+          secret:
+            secretName: minio-key
+      containers:
+      - name:  set-policy
+        image: minio/mc:RELEASE.2017-10-14T00-51-16Z
+        command: ["sh", "-c"]
+        args: [ "\
+          mc config host add minioserver http://minio.kubeless:9000 $(cat /minio-cred/accesskey) $(cat /minio-cred/secretkey) &&  \
+          mc policy download minioserver/functions" ]
+        volumeMounts:
+          - name: keys
+            mountPath: /minio-cred
+      restartPolicy: OnFailure
diff --git a/pkg/minio/minio.go b/pkg/minio/minio.go
new file mode 100644
index 00000000..26b22bb4
--- /dev/null
+++ b/pkg/minio/minio.go
@@ -0,0 +1,117 @@
+package minio
+
+import (
+	"fmt"
+	"os"
+	"path"
+	"time"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/pkg/api/v1"
+	batchv1 "k8s.io/client-go/pkg/apis/batch/v1"
+)
+
+func waitForCompletedJob(jobName, namespace string, timeout int, cli kubernetes.Interface) error {
+	counter := 0
+	for counter < timeout {
+		j, err := cli.BatchV1().Jobs(namespace).Get(jobName, metav1.GetOptions{})
+		if err != nil {
+			return err
+		}
+		if j.Status.Failed == 1 {
+			err = fmt.Errorf("Unable to run upload job. Received: %s", j.Status.Conditions[0].Message)
+			return err
+		} else if j.Status.Succeeded == 1 {
+			return nil
+		}
+		time.Sleep(time.Duration(time.Second))
+		counter++
+	}
+	return fmt.Errorf("Upload job has not finished after %s seconds", string(timeout))
+}
+
+// UploadFunction uploads a file to Minio using as object name file.extension
+// It uses a Kubernetes job to access Minio since we need to use an URL <domain>[:port] (a URL with
+// proxy is not valid)
+func UploadFunction(file, checksum string, cli kubernetes.Interface) (string, error) {
+	minioCredentials := "minio-key"
+	jobName := "upload-file-" + checksum[0:10]
+	fileName := path.Base(file) + "." + checksum
+	var absPath string
+	if !path.IsAbs(file) {
+		cwd, err := os.Getwd()
+		if err != nil {
+			return "", err
+		}
+		absPath = path.Join(cwd, file)
+	} else {
+		absPath = file
+	}
+	job := batchv1.Job{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:      jobName,
+			Namespace: "kubeless",
+		},
+		Spec: batchv1.JobSpec{
+			Template: v1.PodTemplateSpec{
+				Spec: v1.PodSpec{
+					Volumes: []v1.Volume{
+						{
+							Name: minioCredentials,
+							VolumeSource: v1.VolumeSource{
+								Secret: &v1.SecretVolumeSource{
+									SecretName: minioCredentials,
+								},
+							},
+						},
+						{
+							Name: "func",
+							VolumeSource: v1.VolumeSource{
+								HostPath: &v1.HostPathVolumeSource{
+									Path: absPath,
+								},
+							},
+						},
+					},
+					RestartPolicy: v1.RestartPolicyNever,
+					Containers: []v1.Container{
+						{
+							Name:  "uploader",
+							Image: "minio/mc:RELEASE.2017-10-14T00-51-16Z",
+							VolumeMounts: []v1.VolumeMount{
+								{
+									Name:      minioCredentials,
+									MountPath: "/minio-cred",
+								},
+								{
+									Name:      "func",
+									MountPath: "/" + path.Base(file),
+								},
+							},
+							Command: []string{"sh", "-c"},
+							Args: []string{
+								"mc config host add minioserver http://minio.kubeless:9000 $(cat /minio-cred/accesskey) $(cat /minio-cred/secretkey); " +
+									"mc cp /" + path.Base(file) + " minioserver/functions/" + fileName,
+							},
+						},
+					},
+				},
+			},
+		},
+	}
+	_, err := cli.BatchV1().Jobs("kubeless").Create(&job)
+	if err != nil {
+		return "", err
+	}
+	waitErr := waitForCompletedJob(jobName, "kubeless", 120, cli)
+	// Clean up (delete job)
+	err = cli.BatchV1().Jobs("kubeless").Delete(jobName, &metav1.DeleteOptions{})
+	if waitErr != nil {
+		return "", waitErr
+	}
+	if err != nil {
+		return "", err
+	}
+	return "http://minio.kubeless:9000/functions/" + fileName, nil
+}
diff --git a/pkg/minio/minio_test.go b/pkg/minio/minio_test.go
new file mode 100644
index 00000000..0a1d931c
--- /dev/null
+++ b/pkg/minio/minio_test.go
@@ -0,0 +1,41 @@
+package minio
+
+import (
+	"fmt"
+	"path"
+	"testing"
+
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/client-go/kubernetes/fake"
+	batchv1 "k8s.io/client-go/pkg/apis/batch/v1"
+	core "k8s.io/client-go/testing"
+)
+
+func TestUploadFunction(t *testing.T) {
+	// Fake successful job
+	uploadFakeJob := batchv1.Job{
+		ObjectMeta: metav1.ObjectMeta{
+			Namespace: "kubeless",
+			Name:      "upload-file",
+		},
+		Status: batchv1.JobStatus{
+			Succeeded: 1,
+		},
+	}
+	file := "/path/to/func.ext"
+	checksum := "abcdefghijklm1234567890"
+	cli := &fake.Clientset{}
+	cli.Fake.AddReactor("get", "jobs", func(action core.Action) (bool, runtime.Object, error) {
+		return true, &uploadFakeJob, nil
+	})
+
+	// It should return a valid URL
+	url, err := UploadFunction(file, checksum, cli)
+	if err != nil {
+		t.Errorf("Unexpected error %s", err)
+	}
+	if url != fmt.Sprintf("http://minio.kubeless:9000/functions/%s.%s", path.Base(file), checksum) {
+		t.Errorf("Unexpected url %s", url)
+	}
+}
diff --git a/pkg/utils/k8sutil_test.go b/pkg/utils/k8sutil_test.go
index 0832f0cb..530331e9 100644
--- a/pkg/utils/k8sutil_test.go
+++ b/pkg/utils/k8sutil_test.go
@@ -637,6 +637,15 @@ func TestGetProvisionContainer(t *testing.T) {
 		t.Errorf("Unexpected result:\n %+v", c)
 	}
 
+	// If the content type is an URL it should download the file
+	c, err = getProvisionContainer("http://file.com/test.func", "sha256:abc1234", "test.func", "test.foo", "URL", "python2.7", rvol, dvol)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	if !strings.HasPrefix(c.Args[0], "curl -L http://file.com/test.func -o /deps/test.func") {
+		t.Errorf("Unexpected command: %s", c.Args[0])
+	}
+
 	// If the content type is encoded it should decode it
 	c, err = getProvisionContainer("Zm9vYmFyCg==", "sha256:abc1234", "test.func", "test.foo", "base64", "python2.7", rvol, dvol)
 	if err != nil {
diff --git a/script/libtest.bash b/script/libtest.bash
index 046521ed..6d783acf 100644
--- a/script/libtest.bash
+++ b/script/libtest.bash
@@ -311,4 +311,14 @@ test_kubeless_autoscale() {
     k8s_wait_for_pod_count ${num} -l function="${func}"
     kubeless autoscale delete ${func}
 }
+deploy_manifest() {
+    local manifest=${1:?}
+    echo_info "Deploying ${manifest}"
+    kubectl create -f ${manifest}
+}
+teardown_manifest() {
+    local manifest=${1:?}
+    echo_info "Deploying ${manifest}"
+    kubectl delete -f ${manifest}
+}
 # vim: sw=4 ts=4 et si
diff --git a/tests/integration-tests.bats b/tests/integration-tests.bats
index 3e6e2bb2..52a46e2a 100644
--- a/tests/integration-tests.bats
+++ b/tests/integration-tests.bats
@@ -130,4 +130,13 @@ load ../script/libtest
   wait_for_endpoint webserver
   verify_update_function webserver
 }
+@test "Test function stored in Minio" {
+  kubectl create secret generic minio-key --namespace kubeless --from-literal=accesskey=foobar --from-literal=secretkey=foobarfoo
+  deploy_manifest "$(pwd)/manifests/minio/minio.yaml"
+  k8s_wait_for_pod_ready -l kubeless=minio -n kubeless
+  test_kubeless_function get-python
+  kubectl describe pod -l function=get-python | grep "curl -L http://minio.kubeless:9000"
+  teardown_manifest "$(pwd)/manifests/minio/minio.yaml"
+  kubectl delete secret --namespace kubeless minio-key
+}
 # vim: ts=2 sw=2 si et syntax=sh
