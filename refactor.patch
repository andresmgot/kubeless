diff --git a/cmd/kubeless-controller/kubeless-controller.go b/cmd/kubeless-controller/kubeless-controller.go
index 9c8d2785..43b8e3e8 100644
--- a/cmd/kubeless-controller/kubeless-controller.go
+++ b/cmd/kubeless-controller/kubeless-controller.go
@@ -41,13 +41,13 @@ var rootCmd = &cobra.Command{
 	Short: "Kubeless controller",
 	Long:  globalUsage,
 	Run: func(cmd *cobra.Command, args []string) {
-		tprClient, err := utils.GetTPRClient()
+		crdClient, err := utils.GetCRDClient()
 		if err != nil {
 			logrus.Fatalf("Cannot get TPR client: %v", err)
 		}
 		cfg := controller.Config{
 			KubeCli:   utils.GetClient(),
-			TprClient: tprClient,
+			TprClient: crdClient,
 		}
 		c := controller.New(cfg)
 		stopCh := make(chan struct{})
diff --git a/cmd/kubeless/call.go b/cmd/kubeless/call.go
index 46db1477..4d1b15e5 100644
--- a/cmd/kubeless/call.go
+++ b/cmd/kubeless/call.go
@@ -21,21 +21,15 @@ import (
 	"fmt"
 	"strconv"
 	"strings"
-	"time"
 
 	"github.com/Sirupsen/logrus"
 	"github.com/kubeless/kubeless/pkg/utils"
 	"github.com/spf13/cobra"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/client-go/pkg/api"
-	"k8s.io/client-go/pkg/api/v1"
 	"k8s.io/client-go/rest"
 )
 
-const (
-	maxRetries       = 5
-	defaultTimeSleep = 1 * time.Second
-)
-
 var callCmd = &cobra.Command{
 	Use:   "call <function_name> FLAG",
 	Short: "call function from cli",
@@ -66,10 +60,9 @@ var callCmd = &cobra.Command{
 			logrus.Fatal(err)
 		}
 
-		tprClient, err := utils.GetTPRClientOutOfCluster()
-		svc := v1.Service{}
-		tprClient.Get().AbsPath("/api/v1/namespaces/" + ns + "/services/" + funcName + "/").Do().Into(&svc)
-		if svc.ObjectMeta.Name != funcName {
+		clientset := utils.GetClientOutOfCluster()
+		svc, err := clientset.CoreV1().Services(ns).Get(funcName, metav1.GetOptions{})
+		if err != nil {
 			logrus.Fatalf("Unable to find the service for %s", funcName)
 		}
 
@@ -77,13 +70,17 @@ var callCmd = &cobra.Command{
 		if svc.Spec.Ports[0].Name != "" {
 			port = svc.Spec.Ports[0].Name
 		}
-		url := "/api/v1/proxy/namespaces/" + ns + "/services/" + funcName + ":" + port + "/"
 
 		req := &rest.Request{}
+		cli, err := utils.GetRestClientOutOfCluster("", "v1", "/api")
 		if get {
-			req = tprClient.Get().AbsPath(url)
+			req = cli.Get().Namespace(ns).Resource("services").SubResource("proxy").Name(funcName + ":" + port)
 		} else {
-			req = tprClient.Post().AbsPath(url).Body(bytes.NewBuffer(jsonStr)).SetHeader("Content-Type", "application/json")
+			req = cli.Post().Body(bytes.NewBuffer(jsonStr)).SetHeader("Content-Type", "application/json")
+			// REST package removes trailing slash when building URLs
+			// Causing POST requests to be redirected with an empty body
+			// So we need to manually build the URL
+			req = req.AbsPath(svc.ObjectMeta.SelfLink + ":" + port + "/proxy/")
 		}
 		res, err := req.Do().Raw()
 		if err != nil {
diff --git a/cmd/kubeless/delete.go b/cmd/kubeless/delete.go
index d27135c4..f046bc72 100644
--- a/cmd/kubeless/delete.go
+++ b/cmd/kubeless/delete.go
@@ -37,12 +37,12 @@ var deleteCmd = &cobra.Command{
 		if err != nil {
 			logrus.Fatal(err)
 		}
-		tprClient, err := utils.GetTPRClientOutOfCluster()
+		crdClient, err := utils.GetCRDClientOutOfCluster()
 		if err != nil {
 			logrus.Fatal(err)
 		}
 
-		err = utils.DeleteK8sCustomResource(tprClient, funcName, ns)
+		err = utils.DeleteK8sCustomResource(crdClient, funcName, ns)
 		if err != nil {
 			logrus.Fatal(err)
 		}
diff --git a/cmd/kubeless/deploy.go b/cmd/kubeless/deploy.go
index 0ab7b3c8..31ea0725 100644
--- a/cmd/kubeless/deploy.go
+++ b/cmd/kubeless/deploy.go
@@ -17,6 +17,7 @@ limitations under the License.
 package main
 
 import (
+	"io/ioutil"
 	"strings"
 
 	"github.com/Sirupsen/logrus"
@@ -97,36 +98,31 @@ var deployCmd = &cobra.Command{
 			logrus.Fatal(err)
 		}
 
-		funcContent := ""
-		if len(file) != 0 {
-			funcContent, err = readFile(file)
-			if err != nil {
-				logrus.Fatalf("Unable to read file %s: %v", file, err)
-			}
-		}
-
 		funcDeps := ""
 		if deps != "" {
-			funcDeps, err = readFile(deps)
+			bytes, err := ioutil.ReadFile(deps)
 			if err != nil {
 				logrus.Fatalf("Unable to read file %s: %v", deps, err)
 			}
+			funcDeps = string(bytes)
 		}
 
-		f, err := getFunctionDescription(funcName, ns, handler, funcContent, funcDeps, runtime, topic, schedule, runtimeImage, mem, triggerHTTP, envs, labels, spec.Function{})
+		cli := utils.GetClientOutOfCluster()
+		f, err := getFunctionDescription(cli, funcName, ns, handler, file, funcDeps, runtime, topic, schedule, runtimeImage, mem, triggerHTTP, envs, labels, spec.Function{})
 		if err != nil {
 			logrus.Fatal(err)
 		}
 
-		tprClient, err := utils.GetTPRClientOutOfCluster()
+		crdClient, err := utils.GetCRDClientOutOfCluster()
 		if err != nil {
 			logrus.Fatal(err)
 		}
-
-		err = utils.CreateK8sCustomResource(tprClient, f)
+		logrus.Infof("Creating function...")
+		err = utils.CreateK8sCustomResource(crdClient, f)
 		if err != nil {
 			logrus.Fatal(err)
 		}
+		logrus.Infof("Function %s submitted for deployment", funcName)
 	},
 }
 
diff --git a/cmd/kubeless/function.go b/cmd/kubeless/function.go
index 021dd1f5..bab367a6 100644
--- a/cmd/kubeless/function.go
+++ b/cmd/kubeless/function.go
@@ -17,14 +17,23 @@ limitations under the License.
 package main
 
 import (
+	"crypto/sha256"
+	"encoding/base64"
+	"encoding/hex"
+	"errors"
 	"fmt"
+	"io"
 	"io/ioutil"
+	"net/http"
+	"os"
+	"path"
 	"strings"
 
 	"github.com/kubeless/kubeless/pkg/spec"
 	"github.com/spf13/cobra"
 	"k8s.io/apimachinery/pkg/api/resource"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes"
 	"k8s.io/client-go/pkg/api/v1"
 )
 
@@ -62,14 +71,6 @@ func getKV(input string) (string, string) {
 	return key, value
 }
 
-func readFile(file string) (string, error) {
-	data, err := ioutil.ReadFile(file)
-	if err != nil {
-		return "", err
-	}
-	return string(data[:]), nil
-}
-
 func parseLabel(labels []string) map[string]string {
 	funcLabels := map[string]string{}
 	for _, label := range labels {
@@ -100,14 +101,81 @@ func parseMemory(mem string) (resource.Quantity, error) {
 	return quantity, nil
 }
 
-func getFunctionDescription(funcName, ns, handler, funcContent, deps, runtime, topic, schedule, runtimeImage, mem string, triggerHTTP bool, envs, labels []string, defaultFunction spec.Function) (f *spec.Function, err error) {
+func getFileSha256(file string) (string, error) {
+	h := sha256.New()
+	ff, err := os.Open(file)
+	if err != nil {
+		return "", err
+	}
+	defer ff.Close()
+	_, err = io.Copy(h, ff)
+	if err != nil {
+		return "", err
+	}
+	checksum := hex.EncodeToString(h.Sum(nil))
+	return checksum, err
+}
+
+func uploadFunction(file string, cli kubernetes.Interface) (string, string, string, error) {
+	stats, err := os.Stat(file)
+	if err != nil {
+		return "", "", "", err
+	}
+	if stats.Size() > int64(50*1024*1024) { // TODO: Make the max file size (50 MB) configurable
+		err = errors.New("The maximum size of a function is 50MB")
+		return "", "", "", err
+	}
+	// If an object storage service is not available check
+	// that the file is not over 1MB to store it as a Custom Resource
+	if stats.Size() > int64(1*1024*1024) {
+		err = errors.New("Unable to deploy functions over 1MB withouth a storage service")
+		return "", "", "", err
+	}
+	functionBytes, err := ioutil.ReadFile(file)
+	if err != nil {
+		return "", "", "", err
+	}
+	if err != nil {
+		return "", "", "", err
+	}
+	fileType := http.DetectContentType(functionBytes)
+	var function, contentType string
+	if strings.Contains(fileType, "text/plain") {
+		function = string(functionBytes)
+		contentType = "text"
+	} else {
+		function = base64.StdEncoding.EncodeToString(functionBytes)
+		contentType = "base64"
+		if strings.Contains(fileType, "zip") {
+			contentType += "+zip"
+		}
+	}
+	c, err := getFileSha256(file)
+	if err != nil {
+		return "", "", "", err
+	}
+	checksum := "sha256:" + c
+	return function, contentType, checksum, nil
+}
+
+func getFunctionDescription(cli kubernetes.Interface, funcName, ns, handler, file, deps, runtime, topic, schedule, runtimeImage, mem string, triggerHTTP bool, envs, labels []string, defaultFunction spec.Function) (*spec.Function, error) {
 
 	if handler == "" {
 		handler = defaultFunction.Spec.Handler
 	}
 
-	if funcContent == "" {
-		funcContent = defaultFunction.Spec.Function
+	var function, checksum, contentType string
+	if file == "" {
+		file = defaultFunction.Spec.File
+		contentType = defaultFunction.Spec.FunctionContentType
+		function = defaultFunction.Spec.Function
+		checksum = defaultFunction.Spec.Checksum
+	} else {
+		var err error
+		function, contentType, checksum, err = uploadFunction(file, cli)
+		if err != nil {
+			return &spec.Function{}, err
+		}
 	}
 
 	if deps == "" {
@@ -149,13 +217,12 @@ func getFunctionDescription(funcName, ns, handler, funcContent, deps, runtime, t
 		funcLabels = defaultFunction.Metadata.Labels
 	}
 
-	funcMem := resource.Quantity{}
 	resources := v1.ResourceRequirements{}
 	if mem != "" {
-		funcMem, err = parseMemory(mem)
+		funcMem, err := parseMemory(mem)
 		if err != nil {
-			err = fmt.Errorf("Wrong format of the memory value: %v", err)
-			return
+			err := fmt.Errorf("Wrong format of the memory value: %v", err)
+			return &spec.Function{}, err
 		}
 		resource := map[v1.ResourceName]resource.Quantity{
 			v1.ResourceMemory: funcMem,
@@ -174,7 +241,7 @@ func getFunctionDescription(funcName, ns, handler, funcContent, deps, runtime, t
 		runtimeImage = defaultFunction.Spec.Template.Spec.Containers[0].Image
 	}
 
-	f = &spec.Function{
+	return &spec.Function{
 		TypeMeta: metav1.TypeMeta{
 			Kind:       "Function",
 			APIVersion: "k8s.io/v1",
@@ -185,13 +252,16 @@ func getFunctionDescription(funcName, ns, handler, funcContent, deps, runtime, t
 			Labels:    funcLabels,
 		},
 		Spec: spec.FunctionSpec{
-			Handler:  handler,
-			Runtime:  runtime,
-			Type:     funcType,
-			Function: funcContent,
-			Deps:     deps,
-			Topic:    topic,
-			Schedule: schedule,
+			Handler:             handler,
+			Runtime:             runtime,
+			Type:                funcType,
+			Function:            function,
+			File:                path.Base(file),
+			Checksum:            checksum,
+			FunctionContentType: contentType,
+			Deps:                deps,
+			Topic:               topic,
+			Schedule:            schedule,
 			Template: v1.PodTemplateSpec{
 				Spec: v1.PodSpec{
 					Containers: []v1.Container{
@@ -204,6 +274,5 @@ func getFunctionDescription(funcName, ns, handler, funcContent, deps, runtime, t
 				},
 			},
 		},
-	}
-	return
+	}, nil
 }
diff --git a/cmd/kubeless/function_test.go b/cmd/kubeless/function_test.go
index b7575b44..ae65f0a8 100644
--- a/cmd/kubeless/function_test.go
+++ b/cmd/kubeless/function_test.go
@@ -17,13 +17,19 @@ limitations under the License.
 package main
 
 import (
+	"archive/zip"
+	"io"
+	"io/ioutil"
 	"k8s.io/client-go/pkg/api/v1"
+	"os"
+	"path"
 	"reflect"
 	"testing"
 
 	"github.com/kubeless/kubeless/pkg/spec"
 	"k8s.io/apimachinery/pkg/api/resource"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes/fake"
 )
 
 func TestParseLabel(t *testing.T) {
@@ -80,8 +86,19 @@ func TestParseEnv(t *testing.T) {
 }
 
 func TestGetFunctionDescription(t *testing.T) {
-	// It should take parse the given values
-	result, err := getFunctionDescription("test", "default", "file.handler", "function", "dependencies", "runtime", "", "", "test-image", "128Mi", true, []string{"TEST=1"}, []string{"test=1"}, spec.Function{})
+	// It should parse the given values
+	file, err := ioutil.TempFile("", "test")
+	if err != nil {
+		t.Error(err)
+	}
+	_, err = file.WriteString("function")
+	if err != nil {
+		t.Error(err)
+	}
+	file.Close()
+	defer os.Remove(file.Name()) // clean up
+
+	result, err := getFunctionDescription(fake.NewSimpleClientset(), "test", "default", "file.handler", file.Name(), "dependencies", "runtime", "", "", "test-image", "128Mi", true, []string{"TEST=1"}, []string{"test=1"}, spec.Function{})
 	if err != nil {
 		t.Error(err)
 	}
@@ -99,13 +116,16 @@ func TestGetFunctionDescription(t *testing.T) {
 			},
 		},
 		Spec: spec.FunctionSpec{
-			Handler:  "file.handler",
-			Runtime:  "runtime",
-			Type:     "HTTP",
-			Function: "function",
-			Deps:     "dependencies",
-			Topic:    "",
-			Schedule: "",
+			Handler:             "file.handler",
+			Runtime:             "runtime",
+			Type:                "HTTP",
+			Function:            "function",
+			Checksum:            "sha256:78f9ac018e554365069108352dacabb7fbd15246edf19400677e3b54fe24e126",
+			File:                path.Base(file.Name()),
+			FunctionContentType: "text",
+			Deps:                "dependencies",
+			Topic:               "",
+			Schedule:            "",
 			Template: v1.PodTemplateSpec{
 				Spec: v1.PodSpec{
 					Containers: []v1.Container{
@@ -130,11 +150,11 @@ func TestGetFunctionDescription(t *testing.T) {
 		},
 	}
 	if !reflect.DeepEqual(expectedFunction, *result) {
-		t.Error("Unexpected result")
+		t.Errorf("Unexpected result. Expecting:\n %+v\nReceived:\n %+v", expectedFunction, *result)
 	}
 
 	// It should take the default values
-	result2, err := getFunctionDescription("test", "default", "", "", "", "", "", "", "", "", false, []string{}, []string{}, expectedFunction)
+	result2, err := getFunctionDescription(fake.NewSimpleClientset(), "test", "default", "", "", "", "", "", "", "", "", false, []string{}, []string{}, expectedFunction)
 	if err != nil {
 		t.Error(err)
 	}
@@ -143,11 +163,21 @@ func TestGetFunctionDescription(t *testing.T) {
 	}
 
 	// Given parameters should take precedence from default values
-	result3, err := getFunctionDescription("test", "default", "file.handler2", "function2", "dependencies2", "runtime2", "test_topic", "", "test-image2", "256Mi", false, []string{"TEST=2"}, []string{"test=2"}, expectedFunction)
+	file, err = ioutil.TempFile("", "test")
+	if err != nil {
+		t.Error(err)
+	}
+	_, err = file.WriteString("function-modified")
 	if err != nil {
 		t.Error(err)
 	}
-	parsedMem, _ = parseMemory("256Mi")
+	file.Close()
+	defer os.Remove(file.Name()) // clean up
+	result3, err := getFunctionDescription(fake.NewSimpleClientset(), "test", "default", "file.handler2", file.Name(), "dependencies2", "runtime2", "test_topic", "", "test-image2", "256Mi", false, []string{"TEST=2"}, []string{"test=2"}, expectedFunction)
+	if err != nil {
+		t.Error(err)
+	}
+	parsedMem2, _ := parseMemory("256Mi")
 	newFunction := spec.Function{
 		TypeMeta: metav1.TypeMeta{
 			Kind:       "Function",
@@ -161,13 +191,16 @@ func TestGetFunctionDescription(t *testing.T) {
 			},
 		},
 		Spec: spec.FunctionSpec{
-			Handler:  "file.handler2",
-			Runtime:  "runtime2",
-			Type:     "PubSub",
-			Function: "function2",
-			Deps:     "dependencies2",
-			Topic:    "test_topic",
-			Schedule: "",
+			Handler:             "file.handler2",
+			Runtime:             "runtime2",
+			Type:                "PubSub",
+			Function:            "function-modified",
+			File:                path.Base(file.Name()),
+			FunctionContentType: "text",
+			Checksum:            "sha256:1958eb96d7d3cadedd0f327f09322eb7db296afb282ed91aa66cb4ab0dcc3c9f",
+			Deps:                "dependencies2",
+			Topic:               "test_topic",
+			Schedule:            "",
 			Template: v1.PodTemplateSpec{
 				Spec: v1.PodSpec{
 					Containers: []v1.Container{
@@ -178,10 +211,10 @@ func TestGetFunctionDescription(t *testing.T) {
 							}},
 							Resources: v1.ResourceRequirements{
 								Limits: map[v1.ResourceName]resource.Quantity{
-									v1.ResourceMemory: parsedMem,
+									v1.ResourceMemory: parsedMem2,
 								},
 								Requests: map[v1.ResourceName]resource.Quantity{
-									v1.ResourceMemory: parsedMem,
+									v1.ResourceMemory: parsedMem2,
 								},
 							},
 							Image: "test-image2",
@@ -192,7 +225,43 @@ func TestGetFunctionDescription(t *testing.T) {
 		},
 	}
 	if !reflect.DeepEqual(newFunction, *result3) {
-		t.Error("Unexpected result")
+		t.Errorf("Unexpected result. Expecting:\n %+v\n Received %+v\n", newFunction, *result3)
 	}
 
+	// It should detect that it is a Zip file
+	file, err = os.Open(file.Name())
+	if err != nil {
+		t.Error(err)
+	}
+	newfile, err := os.Create(file.Name() + ".zip")
+	if err != nil {
+		t.Error(err)
+	}
+	defer os.Remove(newfile.Name()) // clean up
+	zipW := zip.NewWriter(newfile)
+	info, err := file.Stat()
+	if err != nil {
+		t.Error(err)
+	}
+	header, err := zip.FileInfoHeader(info)
+	if err != nil {
+		t.Error(err)
+	}
+	writer, err := zipW.CreateHeader(header)
+	if err != nil {
+		t.Error(err)
+	}
+	_, err = io.Copy(writer, file)
+	if err != nil {
+		t.Error(err)
+	}
+	file.Close()
+	zipW.Close()
+	result4, err := getFunctionDescription(fake.NewSimpleClientset(), "test", "default", "file.handler", newfile.Name(), "dependencies", "runtime", "", "", "", "", false, []string{}, []string{}, expectedFunction)
+	if err != nil {
+		t.Error(err)
+	}
+	if result4.Spec.FunctionContentType != "base64+zip" {
+		t.Errorf("Should return base64+zip, received %s", result4.Spec.FunctionContentType)
+	}
 }
diff --git a/cmd/kubeless/ingressCreate.go b/cmd/kubeless/ingressCreate.go
index c8eb4d18..96601b88 100644
--- a/cmd/kubeless/ingressCreate.go
+++ b/cmd/kubeless/ingressCreate.go
@@ -61,11 +61,11 @@ var ingressCreateCmd = &cobra.Command{
 			logrus.Fatal(err)
 		}
 
-		tprClient, err := utils.GetTPRClientOutOfCluster()
+		crdClient, err := utils.GetCRDClientOutOfCluster()
 		if err != nil {
 			logrus.Fatal(err)
 		}
-		err = functionExists(tprClient, funcName, ns)
+		err = functionExists(crdClient, funcName, ns)
 		if err != nil {
 			if k8sErrors.IsNotFound(err) {
 				logrus.Fatalf("function %s doesn't exist in namespace %s", funcName, ns)
@@ -83,9 +83,9 @@ var ingressCreateCmd = &cobra.Command{
 	},
 }
 
-func functionExists(tprClient rest.Interface, function, ns string) error {
+func functionExists(crdClient rest.Interface, function, ns string) error {
 	f := spec.Function{}
-	err := tprClient.Get().
+	err := crdClient.Get().
 		Resource("functions").
 		Namespace(ns).
 		Name(function).
diff --git a/cmd/kubeless/list.go b/cmd/kubeless/list.go
index a4f02e22..8c171cbf 100644
--- a/cmd/kubeless/list.go
+++ b/cmd/kubeless/list.go
@@ -49,12 +49,12 @@ var listCmd = &cobra.Command{
 			logrus.Fatal(err.Error())
 		}
 
-		tprClient, err := utils.GetTPRClientOutOfCluster()
+		crdClient, err := utils.GetCRDClientOutOfCluster()
 		if err != nil {
 			logrus.Fatalf("Can not list functions: %v", err)
 		}
 
-		if err := doList(cmd.OutOrStdout(), tprClient, ns, output, args); err != nil {
+		if err := doList(cmd.OutOrStdout(), crdClient, ns, output, args); err != nil {
 			logrus.Fatal(err.Error())
 		}
 	},
@@ -65,11 +65,11 @@ func init() {
 	listCmd.Flags().StringP("namespace", "n", api.NamespaceDefault, "Specify namespace for the function")
 }
 
-func doList(w io.Writer, tprClient rest.Interface, ns, output string, args []string) error {
+func doList(w io.Writer, crdClient rest.Interface, ns, output string, args []string) error {
 	var list []*spec.Function
 	if len(args) == 0 {
 		funcList := spec.FunctionList{}
-		err := tprClient.Get().
+		err := crdClient.Get().
 			Resource("functions").
 			Namespace(ns).
 			Do().
@@ -82,7 +82,7 @@ func doList(w io.Writer, tprClient rest.Interface, ns, output string, args []str
 		list = make([]*spec.Function, 0, len(args))
 		for _, arg := range args {
 			f := spec.Function{}
-			err := tprClient.Get().
+			err := crdClient.Get().
 				Resource("functions").
 				Namespace(ns).
 				Name(arg).
diff --git a/cmd/kubeless/update.go b/cmd/kubeless/update.go
index 48bd8929..f42ab2b3 100644
--- a/cmd/kubeless/update.go
+++ b/cmd/kubeless/update.go
@@ -50,13 +50,6 @@ var updateCmd = &cobra.Command{
 		if err != nil {
 			logrus.Fatal(err)
 		}
-		funcContent := ""
-		if len(file) != 0 {
-			funcContent, err = readFile(file)
-			if err != nil {
-				logrus.Fatalf("Unable to read file %s: %v", file, err)
-			}
-		}
 
 		runtime, err := cmd.Flags().GetString("runtime")
 		if err != nil {
@@ -102,20 +95,22 @@ var updateCmd = &cobra.Command{
 			logrus.Fatal(err)
 		}
 
-		f, err := getFunctionDescription(funcName, ns, handler, funcContent, "", runtime, topic, schedule, runtimeImage, mem, triggerHTTP, envs, labels, previousFunction)
+		cli := utils.GetClientOutOfCluster()
+		f, err := getFunctionDescription(cli, funcName, ns, handler, file, "", runtime, topic, schedule, runtimeImage, mem, triggerHTTP, envs, labels, previousFunction)
 		if err != nil {
 			logrus.Fatal(err)
 		}
 
-		tprClient, err := utils.GetTPRClientOutOfCluster()
+		crdClient, err := utils.GetCRDClientOutOfCluster()
 		if err != nil {
 			logrus.Fatal(err)
 		}
 
-		err = utils.UpdateK8sCustomResource(tprClient, f)
+		err = utils.UpdateK8sCustomResource(crdClient, f)
 		if err != nil {
 			logrus.Fatal(err)
 		}
+		logrus.Infof("Function %s submitted for deployment", funcName)
 	},
 }
 
diff --git a/docker/runtime/nodejs/lib/helper.js b/docker/runtime/nodejs/lib/helper.js
index bd2d0778..2f84c578 100644
--- a/docker/runtime/nodejs/lib/helper.js
+++ b/docker/runtime/nodejs/lib/helper.js
@@ -11,7 +11,7 @@ function loadFunc(name, handler) {
     mod = require(modPath); // eslint-disable-line global-require
   } catch (e) {
     console.error(
-      'No valid module found for the name: function, Failed to import module:\n' +
+      `No valid module found for the name: ${name}, Failed to import module:\n` +
       `${e.message}`
     );
     process.exit(1);
diff --git a/docker/unzip/Dockerfile b/docker/unzip/Dockerfile
new file mode 100644
index 00000000..9416bb7e
--- /dev/null
+++ b/docker/unzip/Dockerfile
@@ -0,0 +1,3 @@
+FROM alpine:3.6
+RUN apk add --update unzip curl && \
+    rm -rf /var/cache/apk/*
diff --git a/docs/implementing-new-runtime.md b/docs/implementing-new-runtime.md
index 9f433c1e..6a863746 100755
--- a/docs/implementing-new-runtime.md
+++ b/docs/implementing-new-runtime.md
@@ -5,106 +5,181 @@ As of today, Kubeless supports the following languages:
 * Ruby
 * Node.js
 * Python
-* .NET
 
 Each language interpreter is implemented as an image of a Docker container, dispatched by the Kubeless controller.
 
-All the structures that implement  language support are coded in the file `langruntime.go`, located under the `<..>kuberless/pkg/langruntime` directory of the project tree repository.
+All the structures that implement  language support are coded in the file `k8sutil.go`, located under the `<..>kuberless/pkg/utils` directory of the project tree repository.
 
-If you want to extend it and make another language available it is necessary to change the following components:
+If you want to extend it and make another language available (for example .netcore, which is already in progress! :-) it is necessary to change the following components:
 
 ## 1. Change the Const block string structure
 
 In this block of constants declaration, you sould create an entry pointing to the repository of the Docker container image for the runtime of the new language.
 
-Usually there are three entries - one for HTTP triggers, another for event based functions and another one for the Init container that will be used to install dependencies in the build process. If your new runtime implementation will support only HTTP triggers, then create only two entries as follows:
+Usually there are two entries - one for HTTP triggers and another for event based functions. If your new runtime implementation will support only HTTP triggers, then create only one entry as follows:
 
-In the example below, the `dotnetcore2Http` and `dotnetcore2Init` entry was created, pointing to an image of a Docker container running the .netcore runtime.
-
-```patch
+```
 const (
-...
+        python27Http   = "bitnami/kubeless-python@sha256:6789266df0c97333f76e23efd58cf9c7efe24fa3e83b5fc826fd5cc317699b55"
+        python27Pubsub = "bitnami/kubeless-event-consumer@sha256:5ce469529811acf49c4d20bcd8a675be7aa029b43cf5252a8c9375b170859d83"
+        python34Http   = "bitnami/kubeless-python:test@sha256:686cd28cda5fe7bc6db60fa3e8a9a2c57a5eff6a58e66a60179cc1d3fcf1035b"
+        python34Pubsub = "bitnami/kubeless-python-event-consumer@sha256:8f92397258836e9c39948814aa5324c29d96ff3624b66dd70fdbad1ce0a1615e"
+        node6Http      = "bitnami/kubeless-nodejs@sha256:b3c7cec77f973bf7a48cbbb8ea5069cacbaee7044683a275c6f78fa248de17b4"
+        node6Pubsub    = "bitnami/kubeless-nodejs-event-consumer@sha256:b027bfef5f99c3be68772155a1feaf1f771ab9a3c7bb49bef2e939d6b766abec"
+        node8Http      = "bitnami/kubeless-nodejs@sha256:1eff2beae6fcc40577ada75624c3e4d3840a854588526cd8616d66f4e889dfe6"
+        node8Pubsub    = "bitnami/kubeless-nodejs-event-consumer@sha256:4d005c9c0b462750d9ab7f1305897e7a01143fe869d3b722ed3330560f9c7fb5"
+        ruby24Http     = "bitnami/kubeless-ruby@sha256:97b18ac36bb3aa9529231ea565b339ec00d2a5225cf7eb010cd5a6188cf72ab5"
         ruby24Pubsub   = "bitnami/kubeless-ruby-event-consumer@sha256:938a860dbd9b7fb6b4338248a02c92279315c6e42eed0700128b925d3696b606"
-+        dotnetcore2Http   = "mydocker/kubeless-netcore:latest"
-+        dotnetcore2Init   = "mydocker/kubeless-netcore-build:latest"
+        netcore2Http   = "mydocker/kubeless-netcore:latest"
+        busybox        = "busybox@sha256:be3c11fdba7cfe299214e46edc642e09514dbb9bbefcd0d3836c05a1e0cd0642"
+        pubsubFunc     = "PubSub"
+        schedFunc      = "Scheduled"
+)
 ``` 
+In the example below, the `netcore2Http` entry was created, pointing to an image of a Docker container running the .netcore runtime.
 
 ## 2. Include a runtime variable
 
 Each runtime has a variable for it and needs also to be treated by the function `init()` as shown below.
 
-```patch
-var pythonVersions, nodeVersions, rubyVersions, dotnetcoreVersions []runtimeVersion
+```
+var python, node, ruby, netcore []runtimeVersion
 
 func init() {
-...
-+	dotnetcore2 := runtimeVersion{version: "2.0", httpImage: dotnetcore2Http, pubsubImage: "", initImage: dotnetcore2Init}
-+	dotnetcoreVersions = []runtimeVersion{dotnetcore2}
-
-	availableRuntimes = []RuntimeInfo{
-		{ID: "python", versions: pythonVersions, DepName: "requirements.txt", FileNameSuffix: ".py"},
-		{ID: "nodejs", versions: nodeVersions, DepName: "package.json", FileNameSuffix: ".js"},
-		{ID: "ruby", versions: rubyVersions, DepName: "Gemfile", FileNameSuffix: ".rb"},
-+		{ID: "dotnetcore", versions: dotnetcoreVersions, DepName: "requirements.xml", FileNameSuffix: ".cs"},
-	}
-```
+        python27 := runtimeVersion{runtimeID: "python", version: "2.7", httpImage: python27Http, pubsubImage: python27Pubsub}
+        python34 := runtimeVersion{runtimeID: "python", version: "3.4", httpImage: python34Http, pubsubImage: python34Pubsub}
+        python = []runtimeVersion{python27, python34}
 
-## 3. Add the build instructions to include dependencies in the runtime
+        node6 := runtimeVersion{runtimeID: "nodejs", version: "6", httpImage: node6Http, pubsubImage: node6Pubsub}
+        node8 := runtimeVersion{runtimeID: "nodejs", version: "8", httpImage: node8Http, pubsubImage: node8Pubsub}
+        node = []runtimeVersion{node6, node8}
 
-Each runtime has specific instructions to install its dependencies. These instructions are specified in the method `GetBuildContainer()`. About this method you should know:
- - The folder with the function and the dependency files is mounted at `depsVolume.MountPath`
- - Dependencies should be installed in the folder `runtimeVolume.MountPath`
+        ruby24 := runtimeVersion{runtimeID: "ruby", version: "2.4", httpImage: ruby24Http, pubsubImage: ruby24Pubsub}
+        ruby = []runtimeVersion{ruby24}
 
-## 4. Update the deployment to load requirements for the runtime image
+        netcore2 := runtimeVersion{runtimeID: "netcore", version: "2.0", httpImage: netcore2Http, pubsubImage: ""}
+        netcore = []runtimeVersion{netcore2}
+```
 
-Some languages require to specify an environment variable in order to load dependencies from a certain path. If that is the case, update the function `updateDeployment()` to include the required environment variable:
+## 3. Handle the parameters informed by the client
 
-```patch
-func UpdateDeployment(dpm *v1beta1.Deployment, depsPath, runtime string) {
-	switch {
-...
-+	case strings.Contains(runtime, "ruby"):
-+		dpm.Spec.Template.Spec.Containers[0].Env = append(dpm.Spec.Template.Spec.Containers[0].Env, v1.EnvVar{
-+			Name:  "GEM_HOME",
-+			Value: path.Join(depsPath, "ruby/2.4.0"),
-+		})
+In the function `GetFunctionData()`, include a selection for the `case` structure to define the extention of the file for functions and a variable that will host the file name informed as a parameter for kubeless bringing the code to be executed.
+
+```
+func GetFunctionData(runtime, ftype, modName string) (imageName, depName, fileName string, err error) {
+        err = nil
+        imageName = ""
+        depName = ""
+        fileName = ""
+
+        runtimeID := regexp.MustCompile("[a-zA-Z]+").FindString(runtime)
+        version := regexp.MustCompile("[0-9.]+").FindString(runtime)
+
+        var versionsDef []runtimeVersion
+        switch {
+        case runtimeID == "python":
+                fileName = modName + ".py"
+                versionsDef = python
+                depName = "requirements.txt"
+        case runtimeID == "nodejs":
+                fileName = modName + ".js"
+                versionsDef = node
+                depName = "package.json"
+        case runtimeID == "ruby":
+                fileName = modName + ".rb"
+                versionsDef = ruby
+                depName = "Gemfile"
+        case runtimeID == "netcore":
+                fileName = modName + ".cs"
+                versionsDef = netcore
+                depName = "project.json"
+        default:
+                err = errors.New("The given runtime is not valid")
+                return
+        }
+        imageNameEnvVar := ""
 ```
+## 4. Inform an init image as the base stack for your container
 
-This function is called if there are requirements to be injected in your runtime or if it is a custom runtime.
+In the function `getInitImage()`, include a `case` block to treat if the parameter refers to your new runtime.
 
-## 5. Add examples
+```
+func getInitImage(runtime string) string {
+        switch {
+        case strings.Contains(runtime, "python"):
+                branch := getBranchFromRuntime(runtime)
+                if branch == "2.7" {
+                        // TODO: Migrate the image for python 2.7 to an official source (not alpine-based)
+                        return "tuna/python-pillow:2.7.11-alpine"
+                }
+                return "python:" + branch
+        case strings.Contains(runtime, "nodejs"):
+                return "node:6.10-alpine"
+        case strings.Contains(runtime, "ruby"):
+                return "bitnami/ruby:2.4"
+        case strings.Contains(runtime, "netcore"):
+                return "microsoft/aspnetcore-build:2.0"
+        default:
+                return ""
+        }
+}
+```
+As the `return` for the function, inform the name of the base image for your container.
+
+## 5. Set volume mount path for injecting dependencies
 
-In order to demonstrate the usage of the new runtime it will be necessary to add at least three different examples:
- - GET Example: A simple example in which the function returns a "hello world" string or similar.
- - POST Example: Another example in which the function reads the received input and returns a response.
- - Deps Example: In this example the runtime should load an external library (installed via the build process) and produce a response.
+In the function `getVolumeMounts()`, specify the path of a mount point that will be available in the container image to inject dependencies.
 
- The examples should be added to the folder `examples/<language_id>/` and should be added as well to the Makefile present in `examples/Makefile`. Note that the target should be `get-<language_id>`, `post-<language_id>` and `get-<language_id>-deps` for three examples above.
+```
+       case strings.Contains(runtime, "netcore"):
+                return []v1.VolumeMount{
+                        {
+                                Name:      "netcorepath",
+                                MountPath: "/netcorepath",
+                        },
+                        {
+                                Name:      name,
+                                MountPath: "/requirements",
+                        },
+                }
+        default:
+                return []v1.VolumeMount{}
+        }
+}
+```
 
-## 6. Add tests
+## 6. Update the function to handle requirements for the image
 
-For each new runtime, there should be integration tests that deploys the three examples above and check that the function is successfully deployed and that the output of the function is the expected one. For doing so add the counterpart `get-<language_id>-verify`, `post-<language_id>-verify` and `get-<language_id>-deps-verify` in the `examples/Makefile` and enable the execution of these tests in the script `test/integration-tests.bats`:
+Change the function `updateDeployment()` to include a case to handle your new runtime.
 
-```patch
-...
-+@test "Test function: get-dotnetcore" {
-+  test_kubeless_function get-dotnetcore
-+}
-...
-+@test "Test function: post-dotnetcore" {
-+  test_kubeless_function post-dotnetcore
-+}
-...
-+@test "Test function: get-dotnetcore-deps" {
-+  test_kubeless_function get-dotnetcore-deps
-+}
 ```
+        case strings.Contains(runtime, "netcore"):
+                dpm.Spec.Template.Spec.Containers[0].Env = append(dpm.Spec.Template.Spec.Containers[0].Env, v1.EnvVar{
+                        Name:  "DOTNET_HOME",
+                        Value: "/usr/bin/",
+                })
+                dpm.Spec.Template.Spec.Containers[0].VolumeMounts = append(dpm.Spec.Template.Spec.Containers[0].VolumeMounts, v1.VolumeMount{
+                        Name:      "netcorepath",
+                        MountPath: "/opt/kubeless/netcorepath",
+                })
+                dpm.Spec.Template.Spec.Volumes = append(dpm.Spec.Template.Spec.Volumes, v1.Volume{
+                        Name: "netcorepath",
+                        VolumeSource: v1.VolumeSource{
+                                EmptyDir: &v1.EmptyDirVolumeSource{},
+                        },
+                })
+        }
+}
+```
+
+This function is called if there are requirements to be injected in your runtime or if it is a custom runtime.
+
 
-Unit test are encouraged but not required. If there is a specific behaviour that needs testing (and it is not covered by the integration tests) you can add tests at `pkg/langruntime/langruntime_test.go`.
+After these changes, you need to rebuild the project as described in the Dev Guide.
 
-## Conclusion
+You will need also to implement a way for your runtime to handle the function code it received by the kuberless client (just in time compilation or something similar).
 
-Once you have followed the above steps send PR to the kubeless project, the CI system will pick your changes and test them. Once the PR is accepted by one of the maintainers the changes will be merged and included in the next release of Kubeless. 
+The runtime should include also a mechanism to receive its parameters and pass them in the right form to your interpreter. 
 
 Stay tuned for future documentations on these additional steps! :-)
 
diff --git a/examples/Makefile b/examples/Makefile
index 7d5c58db..c585fc7a 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -41,6 +41,14 @@ get-nodejs-deps:
 get-nodejs-deps-verify:
 	kubeless function call get-nodejs-deps --data '{"hello": "world"}' |egrep '{"hello":"world","date"'
 
+get-nodejs-multi:
+	cd nodejs; zip helloFunctions.zip *js
+	kubeless function deploy get-nodejs-multi --trigger-http --runtime nodejs6 --handler index.helloGet --from-file nodejs/helloFunctions.zip
+	rm nodejs/helloFunctions.zip
+
+get-nodejs-multi-verify:
+	kubeless function call get-nodejs-multi |egrep hello.world
+
 get-python-metadata:
 	kubeless function deploy get-python-metadata --trigger-http --runtime python2.7 --handler helloget.foo --from-file python/helloget.py --env foo:bar,bar=foo,foo --memory 128Mi --label foo:bar,bar=foo,foobar
 	echo "curl localhost:8080/api/v1/proxy/namespaces/default/services/get-python-metadata/"
diff --git a/examples/nodejs/package.json b/examples/nodejs/package.json
index 6d936899..0496588a 100644
--- a/examples/nodejs/package.json
+++ b/examples/nodejs/package.json
@@ -2,6 +2,6 @@
     "name": "hellowithdeps",
     "version": "0.0.1",
     "dependencies": {
-        "lodash": "3.10.1"
+        "lodash": "^4.0.0"
     }
 }
diff --git a/pkg/langruntime/langruntime.go b/pkg/langruntime/langruntime.go
index c85b1a8c..70b33c6c 100644
--- a/pkg/langruntime/langruntime.go
+++ b/pkg/langruntime/langruntime.go
@@ -67,10 +67,10 @@ func init() {
 	dotnetcoreVersions = []runtimeVersion{dotnetcore2}
 
 	availableRuntimes = []RuntimeInfo{
-		{ID: "python", versions: pythonVersions, DepName: "requirements.txt", FileNameSuffix: ".py"},
-		{ID: "nodejs", versions: nodeVersions, DepName: "package.json", FileNameSuffix: ".js"},
-		{ID: "ruby", versions: rubyVersions, DepName: "Gemfile", FileNameSuffix: ".rb"},
-		{ID: "dotnetcore", versions: dotnetcoreVersions, DepName: "requirements.xml", FileNameSuffix: ".cs"},
+		RuntimeInfo{ID: "python", versions: pythonVersions, DepName: "requirements.txt", FileNameSuffix: ".py"},
+		RuntimeInfo{ID: "nodejs", versions: nodeVersions, DepName: "package.json", FileNameSuffix: ".js"},
+		RuntimeInfo{ID: "ruby", versions: rubyVersions, DepName: "Gemfile", FileNameSuffix: ".rb"},
+		RuntimeInfo{ID: "dotnetcore", versions: dotnetcoreVersions, DepName: "requirements.xml", FileNameSuffix: ".cs"},
 	}
 }
 
@@ -192,15 +192,11 @@ func GetBuildContainer(runtime string, env []v1.EnvVar, runtimeVolume, depsVolum
 			}
 		}
 		command = "npm config set " + scope + "registry " + registry +
-			" && npm install"
+			" && cd " + depsVolume.MountPath +
+			" && npm install --prefix=" + runtimeVolume.MountPath
 	case strings.Contains(runtime, "ruby"):
 		command = "bundle install --gemfile=" + depsFile + " --path=" + runtimeVolume.MountPath
 	}
-
-	// Copy sources to runtime volume
-	// TODO: Remove when the volume is already populated with those files
-	command += fmt.Sprintf(" && cp -Hr %s/* %s", depsVolume.MountPath, runtimeVolume.MountPath)
-
 	return v1.Container{
 		Name:            "install",
 		Image:           versionInf.initImage,
@@ -208,7 +204,6 @@ func GetBuildContainer(runtime string, env []v1.EnvVar, runtimeVolume, depsVolum
 		Args:            []string{command},
 		VolumeMounts:    []v1.VolumeMount{runtimeVolume, depsVolume},
 		ImagePullPolicy: v1.PullIfNotPresent,
-		WorkingDir:      depsVolume.MountPath,
 		Env:             env,
 	}, nil
 }
diff --git a/pkg/langruntime/langruntime_test.go b/pkg/langruntime/langruntime_test.go
index b73fddb1..fe69a542 100644
--- a/pkg/langruntime/langruntime_test.go
+++ b/pkg/langruntime/langruntime_test.go
@@ -103,9 +103,8 @@ func TestGetBuildContainer(t *testing.T) {
 		Name:            "install",
 		Image:           "tuna/python-pillow:2.7.11-alpine",
 		Command:         []string{"sh", "-c"},
-		Args:            []string{"pip install --prefix=/v1 -r /v2/requirements.txt && cp -Hr /v2/* /v1"},
+		Args:            []string{"pip install --prefix=/v1 -r /v2/requirements.txt"},
 		VolumeMounts:    []v1.VolumeMount{vol1, vol2},
-		WorkingDir:      "/v2",
 		ImagePullPolicy: v1.PullIfNotPresent,
 		Env:             env,
 	}
@@ -125,7 +124,7 @@ func TestGetBuildContainer(t *testing.T) {
 	if c.Image != "node:6.10" {
 		t.Errorf("Unexpected image %s", c.Image)
 	}
-	if !strings.Contains(c.Args[0], "npm config set myorg:registry http://reg.com && npm install") {
+	if c.Args[0] != "npm config set myorg:registry http://reg.com && cd /v2 && npm install --prefix=/v1" {
 		t.Errorf("Unexpected command %s", c.Args[0])
 	}
 
@@ -137,7 +136,7 @@ func TestGetBuildContainer(t *testing.T) {
 	if c.Image != "bitnami/ruby:2.4" {
 		t.Errorf("Unexpected image %s", c.Image)
 	}
-	if !strings.Contains(c.Args[0], "bundle install --gemfile=/v2/Gemfile --path=/v1") {
+	if c.Args[0] != "bundle install --gemfile=/v2/Gemfile --path=/v1" {
 		t.Errorf("Unexpected command %s", c.Args[0])
 	}
 
diff --git a/pkg/spec/spec.go b/pkg/spec/spec.go
index 3a03e666..08fa354d 100644
--- a/pkg/spec/spec.go
+++ b/pkg/spec/spec.go
@@ -31,14 +31,17 @@ type Function struct {
 
 // FunctionSpec contains func specification
 type FunctionSpec struct {
-	Handler  string             `json:"handler"`
-	Function string             `json:"function"`
-	Runtime  string             `json:"runtime"`
-	Type     string             `json:"type"`
-	Topic    string             `json:"topic"`
-	Schedule string             `json:"schedule"`
-	Deps     string             `json:"deps"`
-	Template v1.PodTemplateSpec `json:"template" protobuf:"bytes,3,opt,name=template"`
+	Handler             string             `json:"handler"`               // Function handler: "file.function"
+	Function            string             `json:"function"`              // Function file content or URL of the function
+	FunctionContentType string             `json:"function-content-type"` // Function file content type (plain text, base64 or zip)
+	File                string             `json:"file"`                  // File name that contains the function
+	Checksum            string             `json:"checksum"`              // Checksum of the file
+	Runtime             string             `json:"runtime"`               // Function runtime to use
+	Type                string             `json:"type"`                  // Function trigger type
+	Topic               string             `json:"topic"`                 // Function topic trigger (for PubSub type)
+	Schedule            string             `json:"schedule"`              // Function scheduled time (for Schedule type)
+	Deps                string             `json:"deps"`                  // Function dependencies
+	Template            v1.PodTemplateSpec `json:"template" protobuf:"bytes,3,opt,name=template"`
 }
 
 // FunctionList contains map of functions
diff --git a/pkg/utils/k8sutil.go b/pkg/utils/k8sutil.go
index 5bac8a3b..458e74e4 100644
--- a/pkg/utils/k8sutil.go
+++ b/pkg/utils/k8sutil.go
@@ -23,6 +23,7 @@ import (
 	"net"
 	"net/url"
 	"os"
+	"path"
 	"path/filepath"
 	"strconv"
 	"strings"
@@ -57,6 +58,7 @@ import (
 const (
 	pubsubFunc = "PubSub"
 	busybox    = "busybox@sha256:be3c11fdba7cfe299214e46edc642e09514dbb9bbefcd0d3836c05a1e0cd0642"
+	unzip      = "kubeless/unzip@sha256:f162c062973cca05459834de6ed14c039d45df8cdb76097f50b028a1621b3697"
 )
 
 // GetClient returns a k8s clientset to the request from inside of cluster
@@ -121,38 +123,42 @@ func GetRestClient() (*rest.RESTClient, error) {
 	return restClient, nil
 }
 
-// GetTPRClient returns tpr client to the request from inside of cluster
-func GetTPRClient() (*rest.RESTClient, error) {
-	tprconfig, err := rest.InClusterConfig()
+// GetCRDClient returns CRD client to the request from inside of cluster
+func GetCRDClient() (*rest.RESTClient, error) {
+	config, err := rest.InClusterConfig()
 	if err != nil {
 		return nil, err
 	}
+	crdConfig := configureClient("k8s.io", "v1", "/apis", config)
 
-	configureClient(tprconfig)
-
-	tprclient, err := rest.RESTClientFor(tprconfig)
+	crdclient, err := rest.RESTClientFor(crdConfig)
 	if err != nil {
 		return nil, err
 	}
 
-	return tprclient, nil
+	return crdclient, nil
 }
 
-// GetTPRClientOutOfCluster returns tpr client to the request from outside of cluster
-func GetTPRClientOutOfCluster() (*rest.RESTClient, error) {
-	tprconfig, err := BuildOutOfClusterConfig()
+// GetRestClientOutOfCluster returns a REST client based on a group, API version and path
+func GetRestClientOutOfCluster(group, apiVersion, apiPath string) (*rest.RESTClient, error) {
+	config, err := BuildOutOfClusterConfig()
 	if err != nil {
 		return nil, err
 	}
 
-	configureClient(tprconfig)
+	crdConfig := configureClient(group, apiVersion, apiPath, config)
 
-	tprclient, err := rest.RESTClientFor(tprconfig)
+	client, err := rest.RESTClientFor(crdConfig)
 	if err != nil {
 		return nil, err
 	}
 
-	return tprclient, nil
+	return client, nil
+}
+
+// GetCRDClientOutOfCluster returns crd client to the request from outside of cluster
+func GetCRDClientOutOfCluster() (*rest.RESTClient, error) {
+	return GetRestClientOutOfCluster("k8s.io", "v1", "/apis")
 }
 
 //GetServiceMonitorClientOutOfCluster returns sm client to the request from outside of cluster
@@ -173,12 +179,12 @@ func GetServiceMonitorClientOutOfCluster() (*monitoringv1alpha1.MonitoringV1alph
 func GetFunction(funcName, ns string) (spec.Function, error) {
 	var f spec.Function
 
-	tprClient, err := GetTPRClientOutOfCluster()
+	crdClient, err := GetCRDClientOutOfCluster()
 	if err != nil {
 		return spec.Function{}, err
 	}
 
-	err = tprClient.Get().
+	err = crdClient.Get().
 		Resource("functions").
 		Namespace(ns).
 		Name(funcName).
@@ -195,8 +201,8 @@ func GetFunction(funcName, ns string) (spec.Function, error) {
 }
 
 // CreateK8sCustomResource will create a custom function object
-func CreateK8sCustomResource(tprClient rest.Interface, f *spec.Function) error {
-	err := tprClient.Post().
+func CreateK8sCustomResource(crdClient rest.Interface, f *spec.Function) error {
+	err := crdClient.Post().
 		Resource("functions").
 		Namespace(f.Metadata.Namespace).
 		Body(f).
@@ -209,12 +215,12 @@ func CreateK8sCustomResource(tprClient rest.Interface, f *spec.Function) error {
 }
 
 // UpdateK8sCustomResource applies changes to the function custom object
-func UpdateK8sCustomResource(tprClient rest.Interface, f *spec.Function) error {
+func UpdateK8sCustomResource(crdClient rest.Interface, f *spec.Function) error {
 	data, err := json.Marshal(f)
 	if err != nil {
 		return err
 	}
-	return tprClient.Patch(types.MergePatchType).
+	return crdClient.Patch(types.MergePatchType).
 		Namespace(f.Metadata.Namespace).
 		Resource("functions").
 		Name(f.Metadata.Name).
@@ -223,8 +229,8 @@ func UpdateK8sCustomResource(tprClient rest.Interface, f *spec.Function) error {
 }
 
 // DeleteK8sCustomResource will delete custom function object
-func DeleteK8sCustomResource(tprClient *rest.RESTClient, funcName, ns string) error {
-	err := tprClient.Delete().
+func DeleteK8sCustomResource(crdClient *rest.RESTClient, funcName, ns string) error {
+	err := crdClient.Delete().
 		Resource("functions").
 		Namespace(ns).
 		Name(funcName).
@@ -260,17 +266,96 @@ func GetReadyPod(pods *v1.PodList) (v1.Pod, error) {
 	return v1.Pod{}, errors.New("There is no pod ready")
 }
 
-// configureClient configures tpr client
-func configureClient(config *rest.Config) {
+func appendToCommand(orig string, command ...string) string {
+	if len(orig) > 0 {
+		return fmt.Sprintf("%s && %s", orig, strings.Join(command, " && "))
+	}
+	return strings.Join(command, " && ")
+}
+
+func getProvisionContainer(function, checksum, fileName, handler, contentType, runtime string, runtimeVolume, depsVolume v1.VolumeMount) (v1.Container, error) {
+	prepareCommand := ""
+	originFile := path.Join(depsVolume.MountPath, fileName)
+
+	// Prepare Function file and dependencies
+	if strings.Contains(contentType, "base64") {
+		// File is encoded in base64
+		prepareCommand = appendToCommand(prepareCommand, fmt.Sprintf("base64 -d < %s > %s.decoded", originFile, originFile))
+		originFile = originFile + ".decoded"
+	} else if strings.Contains(contentType, "text") || contentType == "" {
+		// Assumming that function is plain text
+		// So we don't need to preprocess it
+	} else {
+		return v1.Container{}, fmt.Errorf("Unable to prepare function of type %s: Unknown format", contentType)
+	}
+
+	// Validate checksum
+	if checksum == "" {
+		// DEPRECATED: Checksum may be empty
+	} else {
+		checksumInfo := strings.Split(checksum, ":")
+		switch checksumInfo[0] {
+		case "sha256":
+			shaFile := originFile + ".sha256"
+			prepareCommand = appendToCommand(prepareCommand,
+				fmt.Sprintf("echo '%s  %s' > %s", checksumInfo[1], originFile, shaFile),
+				fmt.Sprintf("sha256sum -c %s", shaFile),
+			)
+			break
+		default:
+			return v1.Container{}, fmt.Errorf("Unable to verify checksum %s: Unknown format", checksum)
+		}
+	}
+
+	// Extract content in case it is a Zip file
+	if strings.Contains(contentType, "zip") {
+		prepareCommand = appendToCommand(prepareCommand,
+			fmt.Sprintf("unzip -o %s -d %s", originFile, runtimeVolume.MountPath),
+		)
+	} else {
+		// Copy the target as a single file
+		destFileName, err := getFileName("", handler, runtime)
+		if err != nil {
+			return v1.Container{}, err
+		}
+		dest := path.Join(runtimeVolume.MountPath, destFileName)
+		prepareCommand = appendToCommand(prepareCommand,
+			fmt.Sprintf("cp %s %s", originFile, dest),
+		)
+	}
+
+	// Copy deps file to the installation path
+	runtimeInf, err := langruntime.GetRuntimeInfo(runtime)
+	if err == nil && runtimeInf.DepName != "" {
+		depsFile := path.Join(depsVolume.MountPath, runtimeInf.DepName)
+		prepareCommand = appendToCommand(prepareCommand,
+			fmt.Sprintf("cp %s %s", depsFile, runtimeVolume.MountPath),
+		)
+	}
+
+	return v1.Container{
+		Name:            "prepare",
+		Image:           unzip,
+		Command:         []string{"sh", "-c"},
+		Args:            []string{prepareCommand},
+		VolumeMounts:    []v1.VolumeMount{runtimeVolume, depsVolume},
+		ImagePullPolicy: v1.PullIfNotPresent,
+	}, nil
+}
+
+// configureClient configures crd client
+func configureClient(group, version, apiPath string, config *rest.Config) *rest.Config {
+	var result rest.Config
+	result = *config
 	groupversion := schema.GroupVersion{
-		Group:   "k8s.io",
-		Version: "v1",
+		Group:   group,
+		Version: version,
 	}
 
-	config.GroupVersion = &groupversion
-	config.APIPath = "/apis"
-	config.ContentType = runtime.ContentTypeJSON
-	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: api.Codecs}
+	result.GroupVersion = &groupversion
+	result.APIPath = apiPath
+	result.ContentType = runtime.ContentTypeJSON
+	result.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: api.Codecs}
 
 	schemeBuilder := runtime.NewSchemeBuilder(
 		func(scheme *runtime.Scheme) error {
@@ -283,6 +368,7 @@ func configureClient(config *rest.Config) {
 		})
 	metav1.AddToGroupVersion(api.Scheme, groupversion)
 	schemeBuilder.AddToScheme(api.Scheme)
+	return &result
 }
 
 // addInitContainerAnnotation is a hot fix to add annotation to deployment for init container to run
@@ -389,21 +475,33 @@ func splitHandler(handler string) (string, string, error) {
 	return str[0], str[1], nil
 }
 
+func getFileName(file, handler, runtime string) (string, error) {
+	// DEPRECATED: If the filename is empty, assume that
+	// the destination file will be <handler>.<ext>
+	if file == "" {
+		modName, _, err := splitHandler(handler)
+		if err != nil {
+			return "", err
+		}
+		filename := modName
+		runtimeInf, err := langruntime.GetRuntimeInfo(runtime)
+		if err == nil {
+			filename = modName + runtimeInf.FileNameSuffix
+		}
+		return filename, nil
+	}
+	return file, nil
+}
+
 // EnsureFuncConfigMap creates/updates a config map with a function specification
 func EnsureFuncConfigMap(client kubernetes.Interface, funcObj *spec.Function, or []metav1.OwnerReference) error {
 	configMapData := map[string]string{}
 	var err error
 	if funcObj.Spec.Handler != "" {
-		modName, _, err := splitHandler(funcObj.Spec.Handler)
+		fileName, err := getFileName(funcObj.Spec.File, funcObj.Spec.Handler, funcObj.Spec.Runtime)
 		if err != nil {
 			return err
 		}
-		fileName := modName
-		runtimeInf, err := langruntime.GetRuntimeInfo(funcObj.Spec.Runtime)
-		if err == nil {
-			fileName = modName + runtimeInf.FileNameSuffix
-		}
-
 		configMapData = map[string]string{
 			"handler": funcObj.Spec.Handler,
 			fileName:  funcObj.Spec.Function,
@@ -425,12 +523,7 @@ func EnsureFuncConfigMap(client kubernetes.Interface, funcObj *spec.Function, or
 
 	_, err = client.Core().ConfigMaps(funcObj.Metadata.Namespace).Create(configMap)
 	if err != nil && k8sErrors.IsAlreadyExists(err) {
-		var data []byte
-		data, err = json.Marshal(configMap)
-		if err != nil {
-			return err
-		}
-		_, err = client.Core().ConfigMaps(funcObj.Metadata.Namespace).Patch(configMap.Name, types.StrategicMergePatchType, data)
+		_, err = client.Core().ConfigMaps(funcObj.Metadata.Namespace).Update(configMap)
 		if err != nil && k8sErrors.IsAlreadyExists(err) {
 			// The configmap may already exist and there is nothing to update
 			return nil
@@ -442,34 +535,39 @@ func EnsureFuncConfigMap(client kubernetes.Interface, funcObj *spec.Function, or
 
 // EnsureFuncService creates/updates a function service
 func EnsureFuncService(client kubernetes.Interface, funcObj *spec.Function, or []metav1.OwnerReference) error {
-	svc := &v1.Service{
-		ObjectMeta: metav1.ObjectMeta{
-			Name:            funcObj.Metadata.Name,
-			Labels:          funcObj.Metadata.Labels,
-			OwnerReferences: or,
-		},
-		Spec: v1.ServiceSpec{
-			Ports: []v1.ServicePort{
-				{
-					Name:       "function-port",
-					Port:       8080,
-					TargetPort: intstr.FromInt(8080),
-					NodePort:   0,
-					Protocol:   v1.ProtocolTCP,
-				},
+	svc, err := client.Core().Services(funcObj.Metadata.Namespace).Get(funcObj.Metadata.Name, metav1.GetOptions{})
+	name := funcObj.Metadata.Name
+	labels := funcObj.Metadata.Labels
+	servicePort := v1.ServicePort{
+		Name:       "function-port",
+		Port:       8080,
+		TargetPort: intstr.FromInt(8080),
+		NodePort:   0,
+		Protocol:   v1.ProtocolTCP,
+	}
+	if err != nil && k8sErrors.IsNotFound(err) {
+		svc := v1.Service{
+			ObjectMeta: metav1.ObjectMeta{
+				Name:            name,
+				Labels:          labels,
+				OwnerReferences: or,
+			},
+			Spec: v1.ServiceSpec{
+				Ports:    []v1.ServicePort{servicePort},
+				Selector: labels,
+				Type:     v1.ServiceTypeClusterIP,
 			},
-			Selector: funcObj.Metadata.Labels,
-			Type:     v1.ServiceTypeClusterIP,
-		},
-	}
-	_, err := client.Core().Services(funcObj.Metadata.Namespace).Create(svc)
-	if err != nil && k8sErrors.IsAlreadyExists(err) {
-		var data []byte
-		data, err = json.Marshal(svc)
-		if err != nil {
-			return err
 		}
-		_, err = client.Core().Services(funcObj.Metadata.Namespace).Patch(svc.Name, types.StrategicMergePatchType, data)
+		_, err = client.Core().Services(funcObj.Metadata.Namespace).Create(&svc)
+		return err
+	} else if err == nil {
+		// In case the SVC already exists we should update
+		// just certain fields (for being able to update it)
+		svc.ObjectMeta.Labels = labels
+		svc.ObjectMeta.OwnerReferences = or
+		svc.Spec.Ports = []v1.ServicePort{servicePort}
+		svc.Spec.Selector = funcObj.Metadata.Labels
+		_, err = client.Core().Services(funcObj.Metadata.Namespace).Update(svc)
 		if err != nil && k8sErrors.IsAlreadyExists(err) {
 			// The service may already exist and there is nothing to update
 			return nil
@@ -554,7 +652,17 @@ func EnsureFuncDeployment(client kubernetes.Interface, funcObj *spec.Function, o
 					},
 				},
 			},
-		})
+		},
+	)
+	runtimeVolumeMount := v1.VolumeMount{
+		Name:      runtimeVolumeName,
+		MountPath: runtimePath,
+	}
+	depsVolumeMount := v1.VolumeMount{
+		Name:      depsVolumeName,
+		MountPath: depsPath,
+	}
+
 	if len(dpm.Spec.Template.Spec.Containers) == 0 {
 		dpm.Spec.Template.Spec.Containers = append(dpm.Spec.Template.Spec.Containers, v1.Container{})
 	}
@@ -592,23 +700,34 @@ func EnsureFuncDeployment(client kubernetes.Interface, funcObj *spec.Function, o
 			Name:  "TOPIC_NAME",
 			Value: funcObj.Spec.Topic,
 		})
+	dpm.Spec.Template.Spec.Containers[0].VolumeMounts = append(dpm.Spec.Template.Spec.Containers[0].VolumeMounts, runtimeVolumeMount)
 
-	//prepare init-container for custom runtime
-	initContainer := v1.Container{}
-	if funcObj.Spec.Deps != "" {
-		// ensure that the runtime is supported for installing dependencies
-		_, err = langruntime.GetRuntimeInfo(funcObj.Spec.Runtime)
+	// prepare init-containers if some function is specified
+	if funcObj.Spec.Function != "" {
+		fileName, err := getFileName(funcObj.Spec.File, funcObj.Spec.Handler, funcObj.Spec.Runtime)
 		if err != nil {
-			return fmt.Errorf("Unable to install dependencies for the runtime %s", funcObj.Spec.Runtime)
-		}
-		runtimeVolumeMount := v1.VolumeMount{
-			Name:      runtimeVolumeName,
-			MountPath: runtimePath,
+			return err
 		}
-		depsVolumeMount := v1.VolumeMount{
-			Name:      depsVolumeName,
-			MountPath: depsPath,
+		provisionContainer, err := getProvisionContainer(
+			funcObj.Spec.Function,
+			funcObj.Spec.Checksum,
+			fileName,
+			funcObj.Spec.Handler,
+			funcObj.Spec.FunctionContentType,
+			funcObj.Spec.Runtime,
+			runtimeVolumeMount,
+			depsVolumeMount,
+		)
+		if err != nil {
+			return err
 		}
+		dpm.Spec.Template.Spec.InitContainers = []v1.Container{provisionContainer}
+	}
+	// ensure that the runtime is supported for installing dependencies
+	_, err = langruntime.GetRuntimeInfo(funcObj.Spec.Runtime)
+	if funcObj.Spec.Deps != "" && err != nil {
+		return fmt.Errorf("Unable to install dependencies for the runtime %s", funcObj.Spec.Runtime)
+	} else if funcObj.Spec.Deps != "" {
 		buildContainer, err := langruntime.GetBuildContainer(funcObj.Spec.Runtime, dpm.Spec.Template.Spec.Containers[0].Env, runtimeVolumeMount, depsVolumeMount)
 		if err != nil {
 			return err
@@ -618,21 +737,10 @@ func EnsureFuncDeployment(client kubernetes.Interface, funcObj *spec.Function, o
 			buildContainer,
 		)
 		// update deployment for loading dependencies
-		dpm.Spec.Template.Spec.Containers[0].VolumeMounts = append(dpm.Spec.Template.Spec.Containers[0].VolumeMounts, runtimeVolumeMount)
 		langruntime.UpdateDeployment(dpm, runtimeVolumeMount.MountPath, funcObj.Spec.Runtime)
-		//TODO: remove this when init containers becomes a stable feature
-		addInitContainerAnnotation(dpm)
-	} else {
-		// TODO: remove this when there is a provisioner init container (mount always runtimeVolumeMount)
-		dpm.Spec.Template.Spec.Containers[0].VolumeMounts = append(dpm.Spec.Template.Spec.Containers[0].VolumeMounts, v1.VolumeMount{
-			Name:      depsVolumeName,
-			MountPath: runtimePath,
-		})
-	}
-	// only append non-empty initContainer
-	if initContainer.Name != "" {
-		dpm.Spec.Template.Spec.InitContainers = append(dpm.Spec.Template.Spec.InitContainers, initContainer)
 	}
+	//TODO: remove this when init containers becomes a stable feature
+	addInitContainerAnnotation(dpm)
 
 	// add liveness Probe to deployment
 	if funcObj.Spec.Type != pubsubFunc {
@@ -651,16 +759,10 @@ func EnsureFuncDeployment(client kubernetes.Interface, funcObj *spec.Function, o
 
 	_, err = client.Extensions().Deployments(funcObj.Metadata.Namespace).Create(dpm)
 	if err != nil && k8sErrors.IsAlreadyExists(err) {
-		var data []byte
-		data, err = json.Marshal(dpm)
+		_, err = client.Extensions().Deployments(funcObj.Metadata.Namespace).Update(dpm)
 		if err != nil {
 			return err
 		}
-		_, err = client.Extensions().Deployments(funcObj.Metadata.Namespace).Patch(dpm.Name, types.StrategicMergePatchType, data)
-		if err != nil {
-			return err
-		}
-
 		// kick existing function pods then it will be recreated
 		// with the new data mount from updated configmap.
 		// TODO: This is a workaround.  Do something better.
diff --git a/pkg/utils/k8sutil_test.go b/pkg/utils/k8sutil_test.go
index 54b3bb90..ef6c557d 100644
--- a/pkg/utils/k8sutil_test.go
+++ b/pkg/utils/k8sutil_test.go
@@ -2,6 +2,7 @@ package utils
 
 import (
 	"reflect"
+	"strings"
 	"testing"
 
 	"github.com/kubeless/kubeless/pkg/spec"
@@ -107,6 +108,67 @@ func TestEnsureConfigMap(t *testing.T) {
 	if !reflect.DeepEqual(cm.Data, expectedData) {
 		t.Errorf("Unexpected ConfigMap:\n %+v\nExpecting:\n %+v", cm.Data, expectedData)
 	}
+
+	// It should use the "File" name if present
+	f3Name := "f3"
+	f3 := &spec.Function{
+		Metadata: metav1.ObjectMeta{
+			Name:      f3Name,
+			Namespace: ns,
+		},
+		Spec: spec.FunctionSpec{
+			File:     "file.py",
+			Function: "function",
+			Handler:  "foo.bar",
+			Runtime:  "python2.7",
+		},
+	}
+	err = EnsureFuncConfigMap(clientset, f3, or)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	cm, err = clientset.CoreV1().ConfigMaps(ns).Get(f3Name, metav1.GetOptions{})
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	expectedData = map[string]string{
+		"handler":          "foo.bar",
+		"file.py":          "function",
+		"requirements.txt": "",
+	}
+	if !reflect.DeepEqual(cm.Data, expectedData) {
+		t.Errorf("Unexpected ConfigMap:\n %+v\nExpecting:\n %+v", cm.Data, expectedData)
+	}
+
+	// If there is already a config map it should update the previous one
+	f3 = &spec.Function{
+		Metadata: metav1.ObjectMeta{
+			Name:      f3Name,
+			Namespace: ns,
+		},
+		Spec: spec.FunctionSpec{
+			File:     "file2.py",
+			Function: "function2",
+			Handler:  "foo.bar2",
+			Runtime:  "python3.4",
+		},
+	}
+	err = EnsureFuncConfigMap(clientset, f3, or)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	cm, err = clientset.CoreV1().ConfigMaps(ns).Get(f3Name, metav1.GetOptions{})
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	expectedData = map[string]string{
+		"handler":          "foo.bar2",
+		"file2.py":         "function2",
+		"requirements.txt": "",
+	}
+	if !reflect.DeepEqual(cm.Data, expectedData) {
+		t.Errorf("Unexpected ConfigMap:\n %+v\nExpecting:\n %+v", cm.Data, expectedData)
+	}
 }
 
 func TestEnsureService(t *testing.T) {
@@ -173,6 +235,23 @@ func TestEnsureService(t *testing.T) {
 	if !reflect.DeepEqual(*svc, expectedSVC) {
 		t.Errorf("Unexpected service:\n %+v\nExpecting:\n %+v", *svc, expectedSVC)
 	}
+
+	// If there is already a service it should update the previous one
+	newLabels := map[string]string{
+		"foobar": "barfoo",
+	}
+	f1.Metadata.Labels = newLabels
+	err = EnsureFuncService(clientset, f1, or)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	svc, err = clientset.CoreV1().Services(ns).Get(f1Name, metav1.GetOptions{})
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	if !reflect.DeepEqual(svc.ObjectMeta.Labels, newLabels) {
+		t.Errorf("Unable to update. Received:\n %+v\nExpecting:\n %+v", svc.ObjectMeta.Labels, newLabels)
+	}
 }
 
 func TestEnsureDeployment(t *testing.T) {
@@ -304,8 +383,8 @@ func TestEnsureDeployment(t *testing.T) {
 		t.Errorf("Unexpected container definition. Received:\n %+v\nExpecting:\n %+v", dpm.Spec.Template.Spec.Containers[0], expectedContainer)
 	}
 	// Init containers behavior should be tested with integration tests
-	if len(dpm.Spec.Template.Spec.InitContainers) < 1 {
-		t.Errorf("Expecting at least an init container to install deps")
+	if len(dpm.Spec.Template.Spec.InitContainers) != 2 {
+		t.Errorf("Expecting two init containers: one for preparing the function and other for installing deps")
 	}
 
 	// If no handler and function is given it should not fail
@@ -375,6 +454,22 @@ func TestEnsureDeployment(t *testing.T) {
 		t.Error("It should not setup a liveness probe")
 	}
 
+	// It should update a deployment if it is already present
+	f6 := spec.Function{}
+	f6 = *f1
+	f6.Spec.Handler = "foo.bar2"
+	err = EnsureFuncDeployment(clientset, &f6, or)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	dpm, err = clientset.ExtensionsV1beta1().Deployments(ns).Get(f1Name, metav1.GetOptions{})
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	if getEnvValueFromList("FUNC_HANDLER", dpm.Spec.Template.Spec.Containers[0].Env) != "bar2" {
+		t.Error("Unable to update deployment")
+	}
+
 	// It should return an error if some dependencies are given but the runtime is not supported
 	f7 := spec.Function{}
 	f7 = *f1
@@ -519,3 +614,48 @@ func TestDeleteAutoscaleResource(t *testing.T) {
 		t.Errorf("deleted autoscale with wrong name (%s)", name)
 	}
 }
+
+func TestGetProvisionContainer(t *testing.T) {
+	rvol := v1.VolumeMount{Name: "runtime", MountPath: "/runtime"}
+	dvol := v1.VolumeMount{Name: "deps", MountPath: "/deps"}
+	c, err := getProvisionContainer("test", "sha256:abc1234", "test.func", "test.foo", "text", "python2.7", rvol, dvol)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	expectedContainer := v1.Container{
+		Name:            "prepare",
+		Image:           "kubeless/unzip@sha256:f162c062973cca05459834de6ed14c039d45df8cdb76097f50b028a1621b3697",
+		Command:         []string{"sh", "-c"},
+		Args:            []string{"echo 'abc1234  /deps/test.func' > /deps/test.func.sha256 && sha256sum -c /deps/test.func.sha256 && cp /deps/test.func /runtime/test.py && cp /deps/requirements.txt /runtime"},
+		VolumeMounts:    []v1.VolumeMount{rvol, dvol},
+		ImagePullPolicy: v1.PullIfNotPresent,
+	}
+	if !reflect.DeepEqual(expectedContainer, c) {
+		t.Errorf("Unexpected result:\n %+v", c)
+	}
+
+	// If the content type is encoded it should decode it
+	c, err = getProvisionContainer("Zm9vYmFyCg==", "sha256:abc1234", "test.func", "test.foo", "base64", "python2.7", rvol, dvol)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	if !strings.HasPrefix(c.Args[0], "cat /deps/test.func | base64 -d > /deps/test.func") {
+		t.Errorf("Unexpected command: %s", c.Args[0])
+	}
+
+	// It should skip the dependencies installation if the runtime is not supported
+	c, err = getProvisionContainer("function", "sha256:abc1234", "test.func", "test.foo", "text", "cobol", rvol, dvol)
+	if err != nil {
+		t.Errorf("Unexpected error: %s", err)
+	}
+	if strings.Contains(c.Args[0], "cp /deps ") {
+		t.Errorf("Unexpected command: %s", c.Args[0])
+	}
+
+	// It should extract the file in case it is a Zip
+	c, err = getProvisionContainer("Zm9vYmFyCg==", "sha256:abc1234", "test.zip", "test.foo", "base64+zip", "python2.7", rvol, dvol)
+	if !strings.Contains(c.Args[0], "unzip -o /deps/test.zip -d /runtime") {
+		t.Errorf("Unexpected command: %s", c.Args[0])
+	}
+
+}
diff --git a/tests/integration-tests.bats b/tests/integration-tests.bats
index 93ff3832..3e6e2bb2 100644
--- a/tests/integration-tests.bats
+++ b/tests/integration-tests.bats
@@ -56,6 +56,9 @@ load ../script/libtest
 @test "Test function: get-nodejs-deps" {
   test_kubeless_function get-nodejs-deps
 }
+@test "Test function: get-nodejs-multi" {
+  test_kubeless_function get-nodejs-multi
+}
 @test "Test function: get-ruby" {
   test_kubeless_function get-ruby
 }
